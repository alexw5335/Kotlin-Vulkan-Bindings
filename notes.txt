
Gui model:
	- Each window has a GUI, although there is only one window.
	- A Base can access the GUI that it is in through Gui.current. This
	should only be used in methods that are called by the GUI.
	- Each Base has a protected list of internal children.
		- If a Base is designed to add other children, then it must extend Pane.
	- Each Base has a padding, border, and margin.

- Need to work out how to initialise the GUI, window, and graphics.
	- Make everything global?
- GUIs are not instantiated by the user. They are maintained for each window by the Guis object.
	- val window = Engine.createWindow?
- The Engine object encapsulates the global window, global Vulkan Context, and the global GUI.
- EngineBuilder configures all engine initialisation config.
	- Engine.root = StackPane { }

- For the moment, BaseModels are sufficient for rendering.
	- BaseModel is just an interface with a render function.

- 3 button actions:
	- press (initial press only)
	- hold (doesn't include initial press)
	- release (or click)




Margin and border are not necessary for a simple GUI.

Simplest GUI:

- All sizes are absolute.
- The root's size is always set to the size of the window.
- Bases are aligned according to width, height, and padding.
	- No border not margin
	- Any borders are entirely cosmetic and do not interfere with alignment.
- Parents may change the size of children and children may change the size of parents.
	- E.g. A button's text changes, so it must be resized.
	- E.g. A packed box must conform to the size of its children.
	- E.g. A slider sets the size of its key and track whenever it is resized.
	- E.g. A StackPane always ensures that its children are the same size as it.
- Alignment must not result in immediately requiring another alignment.
	- I.e. A parent that sets the size of its children must not in turn be sized by its children.
	- E.g. A button does not size its text, but its text may size it?



- Push constant allocations can use a linear allocator that is reset every frame.
- Text will require more sophisticated memory management.
- Each character will require 16 bytes. A 256-byte minimum-alignment buffer can fit 16 characters.
	- There is no use in sub-allocating buffers for text.
	- Each Text uses a single buffer
	- Need a heap allocator for a single memory type.
		- Can allocate more DeviceMemory if it is needed.
		- Can use multiple DeviceMemory objects.

How to handle colour changes on press and hover
- Three states: default, hovered, held.
- Set state or handle with events?
- mouseEnter and mouseExit can set hovered
- press can set held.
- heldEnd?
- mouseState: none, hovered, held.
	- Doesn't include press and click as these are strictly events, never states.
- Doesn't need to be an enum.

- Disconnect between models, bases, and styles
	- How to handle things like toggle buttons?
	- Multiple hovered and pressed colours
	- Combinations of models, base subclasses, colours, textures, styles, geometry, etc.
	- Should a button have multiple models?
	- Render by overriding render or by setting a model?
	- How to handle base-specific rendering?

What needs to be given to the EngineBuilder?
- The window dimensions, which should be the same as the size of the GUI.
- The GUI root does not have to be specified at creation time.
	- The dimensions should match up with the window dimensions in order to prevent immediate resizing.
	- Or, the window can be made visible only when the GUI is first set.

EngineBuilder, VkContextBuilder, GUI, root base, window, how to order creation?
- Perhaps don't make everything an object.
- Need a way to enforce window bounds. This is done through a GUI.
- No GUI elements may be instantiated before Engine and Vulkan initialisation is complete.
- Should the GUI store a reference to its graphics?

Text buffer data
- A text has a single buffer.
- If the text changes and the buffer is no longer large enough, then a new one is allocated.

pClearValues is a pointer to an array of clearValueCount VkClearValue structures containing clear values for each
attachment, if the attachment uses a loadOp value of VK_ATTACHMENT_LOAD_OP_CLEAR or if the attachment has a
depth/stencil format and uses a stencilLoadOp value of VK_ATTACHMENT_LOAD_OP_CLEAR. The array is indexed by attachment
number. Only elements corresponding to cleared attachments are used. Other elements of pClearValues are ignored.



How to handle scrolling bases with very large content areas?
- Need to dynamically reset bases and text.
	- E.g. line numbers in a text editor can have their numbers steadily increased.
- Hex editor project
	- A single text component for the line numbers.
		- Not a normal text component.
		- Does not rely on paragraphs



Unsigned integers and Two's Complement signed integers.
0000_0000 can represent 2^8 = 256 possible values, 0..255 inclusive when unsigned.
1111_1111 = 255 (unsigned). 256 cannot be represented.
Signed, -128..127 can be represented, 127 + 128 + 1 = 256 possible values.

binary        unsigned  signed
1111_1111 =   255       -1
1111_1110 =   254       -2
1000_0000 =   128       -128
0111_1111 =   127       127
0111_1110 =   126       126
0000_0000 =   0         0

If the last bit is not set, then signed = unsigned
If the last bit is set, then signed = unsigned - 256



Simple Heap Allocator
- Allocation is done via blocks.
- Each allocation takes up a block.
- Blocks cannot be resized.
- Blocks are sized by powers of two
- The minimum block size is 256 bytes
	- This is a guaranteed alignment size.
- Allocations do not take alignment into account.
- Buffer allocations will not require memory type bits nor alignment
	- vkGetBufferMemoryRequirements will not be needed.
- How to allocate the blocks?
	- List of linear allocators
	- If a new linear allocator is required, it is sized as the
	largest block size * 4 by default